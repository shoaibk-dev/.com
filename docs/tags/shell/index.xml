<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shell on KhanhIceTea B(rain)-log</title>
    <link>https://khanhicetea.com/tags/shell/</link>
    <description>Recent content in Shell on KhanhIceTea B(rain)-log</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 06 Aug 2018 23:59:59 +0000</lastBuildDate>
    
	<atom:link href="https://khanhicetea.com/tags/shell/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>#TIL : Internal Variables in BASH</title>
      <link>https://khanhicetea.com/til/2018-08-06-internal-variables-in-bash/</link>
      <pubDate>Mon, 06 Aug 2018 23:59:59 +0000</pubDate>
      
      <guid>https://khanhicetea.com/til/2018-08-06-internal-variables-in-bash/</guid>
      <description>Internal Variables in BASH $PWD Your current working directory, so you don&amp;rsquo;t have to use CWD=$(pwd)
$OLDPWD Your previous working directory
Note : You can jump directly to it by the command cd -
$SECONDS The number of seconds the script has been running
You can use it for profiling or limiting timeout
TIME_LIMIT=60 while [ &amp;quot;$SECONDS&amp;quot; -le &amp;quot;$TIME_LIMIT&amp;quot; ] do ## Your hard work here done echo &amp;quot;It takes $SECONDS seconds to get here !</description>
    </item>
    
    <item>
      <title>#TIL : BASH tracing commands</title>
      <link>https://khanhicetea.com/til/2017-09-27-bash-tracing-commands/</link>
      <pubDate>Wed, 27 Sep 2017 23:59:59 +0000</pubDate>
      
      <guid>https://khanhicetea.com/til/2017-09-27-bash-tracing-commands/</guid>
      <description>BASH tracing commands Thank Hiro Ishii for teaching me this
set -x will print all running commands in your bash script
So I dove in and look for all set options of BASH.
And this is what I got , http://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html</description>
    </item>
    
    <item>
      <title>#TIL : BASH exiting on first error</title>
      <link>https://khanhicetea.com/til/2017-09-26-bash-exiting-on-first-error/</link>
      <pubDate>Tue, 26 Sep 2017 23:59:59 +0000</pubDate>
      
      <guid>https://khanhicetea.com/til/2017-09-26-bash-exiting-on-first-error/</guid>
      <description> BASH exiting on first error Setting a flag set -e to bash script will let the script exit on first error occurs, so if you want to ignore a command just adding || true to suffix
set -e errorCmd $1 || true echo &amp;quot;Run here !&amp;quot;  And opposite of set -e is set +e, haha of course !
set +e errorCmd $1 echo &amp;quot;Still run here !&amp;quot;  </description>
    </item>
    
    <item>
      <title>#TIL : BASH return a value in function</title>
      <link>https://khanhicetea.com/til/2017-09-26-bash-return-a-value-in-function/</link>
      <pubDate>Tue, 26 Sep 2017 23:59:59 +0000</pubDate>
      
      <guid>https://khanhicetea.com/til/2017-09-26-bash-return-a-value-in-function/</guid>
      <description>BASH return a value in function Creating function is a good way to refactor your bash script. But BASH doesn&amp;rsquo;t support returning a value in true way, so it makes a bit of challenge to handle that.
You can use this trick
hello() { echo &amp;quot;Hello $1&amp;quot; } hw=$(hello &amp;quot;KhanhIceTea&amp;quot;) echo $hw  But what if you want to echo log message in hello function, it will be merged to returned value.</description>
    </item>
    
    <item>
      <title>#TIL : Using BSD find util to find and exec command on file and folder</title>
      <link>https://khanhicetea.com/til/2017-05-22-using-bsd-find-util-to-find-and-exec-command-on-file-and-folder/</link>
      <pubDate>Mon, 22 May 2017 23:59:59 +0000</pubDate>
      
      <guid>https://khanhicetea.com/til/2017-05-22-using-bsd-find-util-to-find-and-exec-command-on-file-and-folder/</guid>
      <description>Using BSD find util to find and exec command on file and folder Simple syntax of find
$ find [find_path] -type [file_type] -exec [command] {} \;  Add filename matching pattern to filter the result
$ find [find_path] -name &amp;quot;*.php&amp;quot; -type [file_type] -exec [command] {} \;  Where file_type is :
 b : block special c : character special d : directory f : regular file l : symbolic link p : FIFO s : socket  Examples:</description>
    </item>
    
    <item>
      <title>#TIL : wget Output flag</title>
      <link>https://khanhicetea.com/til/2017-05-19-wget-output-flag/</link>
      <pubDate>Fri, 19 May 2017 23:59:59 +0000</pubDate>
      
      <guid>https://khanhicetea.com/til/2017-05-19-wget-output-flag/</guid>
      <description> wget Output flag -O means output
$ # output file will be index.html or based on header filename $ wget -O www.abc.xyz  $ # output file will be filename.html $ wget -O filename.html www.abc.xyz  $ # output to stdout $ wget -O- www.abc.xyz $ wget -O- https://gist.githubusercontent.com/khanhicetea/4fa9f5103cd7fbc2d2270abce05c9c2b/raw/helloworld.sh | bash  </description>
    </item>
    
    <item>
      <title>#TIL : Bash shell shortcuts</title>
      <link>https://khanhicetea.com/til/2016-03-26-bash-shell-shortcuts/</link>
      <pubDate>Sat, 26 Mar 2016 23:59:59 +0000</pubDate>
      
      <guid>https://khanhicetea.com/til/2016-03-26-bash-shell-shortcuts/</guid>
      <description>Bash shell shortcuts  Ctrl + e : jump cursor to EOL Ctrl + a : jump cursor to BOL (beginning of line) Ctrl + u : delete all from cursor to BOL Ctrl + k : delete all from cursor to EOL Ctrl + r : search history, press again for next search Ctrl + l : clear shell screen Ctrl + c : terminate the command (sometimes have to press twice) Ctrl + z : suspend the command, back to shell.</description>
    </item>
    
  </channel>
</rss>